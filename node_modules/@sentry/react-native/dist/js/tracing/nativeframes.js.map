{"version":3,"file":"nativeframes.js","sourceRoot":"","sources":["../../../src/js/tracing/nativeframes.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Span, Transaction } from '@sentry/core';\nimport type { Event, EventProcessor, Measurements, MeasurementUnit } from '@sentry/types';\nimport { logger, timestampInSeconds } from '@sentry/utils';\n\nimport type { NativeFramesResponse } from '../NativeRNSentry';\nimport { NATIVE } from '../wrapper';\nimport { instrumentChildSpanFinish } from './utils';\n\n/**\n * Timeout from the final native frames fetch to processing the associated transaction.\n * If the transaction is not processed by this time, the native frames will be dropped\n * and not added to the event.\n */\nconst FINAL_FRAMES_TIMEOUT_MS = 2000;\n\nexport interface FramesMeasurements extends Measurements {\n  frames_total: { value: number; unit: MeasurementUnit };\n  frames_slow: { value: number; unit: MeasurementUnit };\n  frames_frozen: { value: number; unit: MeasurementUnit };\n}\n\n/** The listeners for each native frames response, keyed by traceId. This must be global to avoid closure issues and reading outdated values. */\nconst _framesListeners: Map<string, () => void> = new Map();\n\n/** The native frames at the transaction finish time, keyed by traceId. This must be global to avoid closure issues and reading outdated values. */\nconst _finishFrames: Map<string, { timestamp: number; nativeFrames: NativeFramesResponse | null }> = new Map();\n\n/**\n * A margin of error of 50ms is allowed for the async native bridge call.\n * Anything larger would reduce the accuracy of our frames measurements.\n */\nconst MARGIN_OF_ERROR_SECONDS = 0.05;\n\n/**\n * Instrumentation to add native slow/frozen frames measurements onto transactions.\n */\nexport class NativeFramesInstrumentation {\n  /** The native frames at the finish time of the most recent span. */\n  private _lastSpanFinishFrames?: {\n    timestamp: number;\n    nativeFrames: NativeFramesResponse;\n  };\n\n  public constructor(addGlobalEventProcessor: (e: EventProcessor) => void, doesExist: () => boolean) {\n    logger.log('[ReactNativeTracing] Native frames instrumentation initialized.');\n\n    addGlobalEventProcessor(event => this._processEvent(event, doesExist));\n  }\n\n  /**\n   * To be called when a transaction is started.\n   * Logs the native frames at this start point and instruments child span finishes.\n   */\n  public onTransactionStart(transaction: Transaction): void {\n    logger.debug(`[NativeFrames] Fetching frames for root span start (${transaction.spanContext().spanId}).`);\n    void NATIVE.fetchNativeFrames()\n      .then(framesMetrics => {\n        if (framesMetrics) {\n          transaction.setData('__startFrames', framesMetrics);\n        } else {\n          logger.warn(\n            `[NativeFrames] Fetched frames for root span start (${\n              transaction.spanContext().spanId\n            }), but no frames were returned.`,\n          );\n        }\n      })\n      .then(undefined, error => {\n        logger.error(\n          `[NativeFrames] Error while fetching frames for root span start (${transaction.spanContext().spanId})`,\n          error,\n        );\n      });\n\n    instrumentChildSpanFinish(transaction, (_: Span, endTimestamp?: number) => {\n      if (!endTimestamp) {\n        this._onSpanFinish();\n      }\n    });\n  }\n\n  /**\n   * To be called when a transaction is finished\n   */\n  public onTransactionFinish(transaction: Transaction): void {\n    this._fetchEndFramesForTransaction(transaction).then(undefined, (reason: unknown) => {\n      logger.error(\n        `[NativeFrames] Error while fetching frames for root span start (${transaction.spanContext().spanId})`,\n        reason,\n      );\n    });\n  }\n\n  /**\n   * Called on a span finish to fetch native frames to support transactions with trimEnd.\n   * Only to be called when a span does not have an end timestamp.\n   */\n  private _onSpanFinish(): void {\n    const timestamp = timestampInSeconds();\n\n    void NATIVE.fetchNativeFrames()\n      .then(nativeFrames => {\n        if (nativeFrames) {\n          this._lastSpanFinishFrames = {\n            timestamp,\n            nativeFrames,\n          };\n        }\n      })\n      .then(undefined, error => {\n        logger.error(`[NativeFrames] Error while fetching frames for child span end.`, error);\n      });\n  }\n\n  /**\n   * Returns the computed frames measurements and awaits for them if they are not ready yet.\n   */\n  private async _getFramesMeasurements(\n    traceId: string,\n    finalEndTimestamp: number,\n    startFrames: NativeFramesResponse,\n  ): Promise<FramesMeasurements | null> {\n    if (_finishFrames.has(traceId)) {\n      logger.debug(`[NativeFrames] Native end frames already fetched for trace id (${traceId}).`);\n      return this._prepareMeasurements(traceId, finalEndTimestamp, startFrames);\n    }\n\n    return new Promise(resolve => {\n      const timeout = setTimeout(() => {\n        logger.debug(`[NativeFrames] Native end frames listener removed by timeout for trace id (${traceId}).`);\n        _framesListeners.delete(traceId);\n\n        resolve(null);\n      }, 2000);\n\n      _framesListeners.set(traceId, () => {\n        logger.debug(`[NativeFrames] Native end frames listener called for trace id (${traceId}).`);\n        resolve(this._prepareMeasurements(traceId, finalEndTimestamp, startFrames));\n\n        clearTimeout(timeout);\n        _framesListeners.delete(traceId);\n      });\n    });\n  }\n\n  /**\n   * Returns the computed frames measurements given ready data\n   */\n  private _prepareMeasurements(\n    traceId: string,\n    finalEndTimestamp: number, // The actual transaction finish time.\n    startFrames: NativeFramesResponse,\n  ): FramesMeasurements | null {\n    let finalFinishFrames: NativeFramesResponse | undefined;\n\n    const finish = _finishFrames.get(traceId);\n    if (\n      finish &&\n      finish.nativeFrames &&\n      // Must be in the margin of error of the actual transaction finish time (finalEndTimestamp)\n      Math.abs(finish.timestamp - finalEndTimestamp) < MARGIN_OF_ERROR_SECONDS\n    ) {\n      logger.debug(`[NativeFrames] Using frames from root span end (traceId, ${traceId}).`);\n      finalFinishFrames = finish.nativeFrames;\n    } else if (\n      this._lastSpanFinishFrames &&\n      Math.abs(this._lastSpanFinishFrames.timestamp - finalEndTimestamp) < MARGIN_OF_ERROR_SECONDS\n    ) {\n      // Fallback to the last span finish if it is within the margin of error of the actual finish timestamp.\n      // This should be the case for trimEnd.\n      logger.debug(`[NativeFrames] Using native frames from last span end (traceId, ${traceId}).`);\n      finalFinishFrames = this._lastSpanFinishFrames.nativeFrames;\n    } else {\n      logger.warn(\n        `[NativeFrames] Frames were collected within larger than margin of error delay for traceId (${traceId}). Dropping the inaccurate values.`,\n      );\n      return null;\n    }\n\n    const measurements = {\n      frames_total: {\n        value: finalFinishFrames.totalFrames - startFrames.totalFrames,\n        unit: 'none',\n      },\n      frames_frozen: {\n        value: finalFinishFrames.frozenFrames - startFrames.frozenFrames,\n        unit: 'none',\n      },\n      frames_slow: {\n        value: finalFinishFrames.slowFrames - startFrames.slowFrames,\n        unit: 'none',\n      },\n    };\n\n    if (\n      measurements.frames_frozen.value <= 0 &&\n      measurements.frames_slow.value <= 0 &&\n      measurements.frames_total.value <= 0\n    ) {\n      logger.warn(\n        `[NativeFrames] Detected zero slow or frozen frames. Not adding measurements to traceId (${traceId}).`,\n      );\n      return null;\n    }\n\n    return measurements;\n  }\n\n  /**\n   * Fetch finish frames for a transaction at the current time. Calls any awaiting listeners.\n   */\n  private async _fetchEndFramesForTransaction(transaction: Transaction): Promise<void> {\n    const startFrames = transaction.data.__startFrames as NativeFramesResponse | undefined;\n\n    // This timestamp marks when the finish frames were retrieved. It should be pretty close to the transaction finish.\n    const timestamp = timestampInSeconds();\n    let finishFrames: NativeFramesResponse | null = null;\n    if (startFrames) {\n      finishFrames = await NATIVE.fetchNativeFrames();\n    }\n\n    _finishFrames.set(transaction.traceId, {\n      nativeFrames: finishFrames,\n      timestamp,\n    });\n\n    _framesListeners.get(transaction.traceId)?.();\n\n    setTimeout(() => this._cancelEndFrames(transaction), FINAL_FRAMES_TIMEOUT_MS);\n  }\n\n  /**\n   * On a finish frames failure, we cancel the await.\n   */\n  private _cancelEndFrames(transaction: Transaction): void {\n    if (_finishFrames.has(transaction.traceId)) {\n      _finishFrames.delete(transaction.traceId);\n\n      logger.log(\n        `[NativeFrames] Native frames timed out for ${transaction.op} transaction ${transaction.name}. Not adding native frames measurements.`,\n      );\n    }\n  }\n\n  /**\n   * Adds frames measurements to an event. Called from a valid event processor.\n   * Awaits for finish frames if needed.\n   */\n  private async _processEvent(event: Event, doesExist: () => boolean): Promise<Event> {\n    if (!doesExist()) {\n      return event;\n    }\n\n    if (event.type === 'transaction' && event.transaction && event.contexts && event.contexts.trace) {\n      const traceContext = event.contexts.trace as {\n        data?: { [key: string]: unknown };\n        trace_id: string;\n        name?: string;\n        op?: string;\n      };\n\n      const traceId = traceContext.trace_id;\n\n      if (!traceContext.data?.__startFrames) {\n        logger.warn(\n          `[NativeFrames] Start frames of transaction ${event.transaction} (eventId, ${event.event_id}) are missing, but it already ended.`,\n        );\n      }\n\n      if (traceId && traceContext.data?.__startFrames && event.timestamp) {\n        const measurements = await this._getFramesMeasurements(\n          traceId,\n          event.timestamp,\n          traceContext.data.__startFrames as NativeFramesResponse,\n        );\n\n        if (measurements) {\n          logger.log(\n            `[Measurements] Adding measurements to ${traceContext.op} transaction ${\n              event.transaction\n            }: ${JSON.stringify(measurements, undefined, 2)}`,\n          );\n\n          event.measurements = {\n            ...(event.measurements ?? {}),\n            ...measurements,\n          };\n\n          _finishFrames.delete(traceId);\n        }\n\n        delete traceContext.data.__startFrames;\n      }\n    }\n\n    return event;\n  }\n}\n"]}