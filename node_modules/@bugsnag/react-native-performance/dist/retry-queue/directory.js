import { isObject } from '@bugsnag/core-performance';
import '../persistence/index.js';
import timestampFromFilename from './timestamp-from-filename.js';
import { Util } from '../persistence/file-utils.js';

// sort filenames by newest -> oldest, i.e. the largest timestamps come first
// any invalid filenames (where we can't parse a timestamp) are put at the end
function filenameSorter(a, b) {
    const aTimestamp = timestampFromFilename(a);
    // put invalid filenames at the end of the array
    if (!aTimestamp) {
        return 1;
    }
    const bTimestamp = timestampFromFilename(b);
    if (!bTimestamp) {
        return -1;
    }
    const delta = bTimestamp - aTimestamp;
    if (delta !== 0) {
        return delta;
    }
    // if timestamps are equal fall back to default string sorting
    if (a > b) {
        return 1;
    }
    if (a < b) {
        return -1;
    }
    return 0;
}
class RetryQueueDirectory {
    constructor(fileSystem, path) {
        this.fileSystem = fileSystem;
        this.path = path;
    }
    async files() {
        if (!await this.fileSystem.exists(this.path)) {
            return [];
        }
        const files = [];
        for (const file of await this.fileSystem.ls(this.path)) {
            if (!await this.fileSystem.isDir(file)) {
                files.push(Util.basename(file));
            }
        }
        files.sort(filenameSorter);
        return files;
    }
    async read(name) {
        const path = `${this.path}/${Util.basename(name)}`;
        if (await this.fileSystem.exists(path)) {
            return await this.fileSystem.readFile(path);
        }
        return '';
    }
    async write(name, contents) {
        await this.ensureExists();
        const path = `${this.path}/${Util.basename(name)}`;
        await this.fileSystem.writeFile(path, contents);
    }
    async delete(name) {
        const path = `${this.path}/${Util.basename(name)}`;
        if (await this.fileSystem.exists(path)) {
            await this.fileSystem.unlink(path);
        }
    }
    async ensureExists() {
        try {
            await this.fileSystem.mkdir(this.path);
        }
        catch (err) {
            // on Android mkdir will fail if the directory already exists, which isn't
            // an error case we care about
            // on iOS it will succeed unless there's a genuine error
            if (isObject(err) && err.code !== 'EEXIST') {
                throw err;
            }
        }
    }
}

export { RetryQueueDirectory as default };
