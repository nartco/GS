import { defaultNetworkRequestCallback } from '@bugsnag/request-tracker-performance';

const permittedPrefixes = ['http://', 'https://', '/', './', '../'];
// The NetInfo module makes requests to this URL to detect if the device is connected to the internet - we don't want to track these
// see https://github.com/react-native-netinfo/react-native-netinfo/blob/1cd754de6c1fb102a491af418e3b6e831f58855a/src/internal/defaultConfiguration.ts#L4
const NET_INFO_REACHABILITY_URL = 'https://clients3.google.com/generate_204';
class NetworkRequestPlugin {
    constructor(spanFactory, spanContextStorage, xhrTracker) {
        this.spanFactory = spanFactory;
        this.spanContextStorage = spanContextStorage;
        this.xhrTracker = xhrTracker;
        this.ignoredUrls = [NET_INFO_REACHABILITY_URL];
        this.tracePropagationUrls = [];
        this.networkRequestCallback = defaultNetworkRequestCallback;
        this.logger = { debug: console.debug, warn: console.warn, info: console.info, error: console.error };
        this.trackRequest = (startContext) => {
            if (!this.shouldTrackRequest(startContext))
                return;
            const defaultRequestInfo = {
                url: startContext.url,
                type: 'xmlhttprequest'
            };
            const networkRequestInfo = this.networkRequestCallback(defaultRequestInfo);
            // returning null neither creates a span nor propagates trace context
            if (!networkRequestInfo) {
                return {
                    onRequestEnd: undefined,
                    extraRequestHeaders: undefined
                };
            }
            const propagateTraceContext = this.shouldPropagateTraceContext(startContext.url);
            // a span is not created if url is null
            if (!networkRequestInfo.url) {
                return {
                    onRequestEnd: undefined,
                    // propagate trace context if requested using span context
                    extraRequestHeaders: propagateTraceContext ? this.getExtraRequestHeaders() : undefined
                };
            }
            // otherwise, create a span and propagate trace context if requested
            if (typeof networkRequestInfo.url !== 'string') {
                this.logger.warn(`expected url to be a string following network request callback, got ${typeof networkRequestInfo.url}`);
                return;
            }
            const span = this.spanFactory.startNetworkSpan({
                method: startContext.method,
                startTime: startContext.startTime,
                url: networkRequestInfo.url
            });
            return {
                onRequestEnd: (endContext) => {
                    if (endContext.state === 'success') {
                        this.spanFactory.endSpan(span, endContext.endTime, { 'http.status_code': endContext.status });
                    }
                },
                // propagate trace context using network span
                extraRequestHeaders: propagateTraceContext
                    ? this.getExtraRequestHeaders(span)
                    : undefined
            };
        };
    }
    configure(configuration) {
        this.logger = configuration.logger;
        if (configuration.autoInstrumentNetworkRequests) {
            this.ignoredUrls.push(configuration.endpoint);
            this.xhrTracker.onStart(this.trackRequest);
            this.networkRequestCallback = configuration.networkRequestCallback;
            this.tracePropagationUrls = configuration.tracePropagationUrls.map((url) => typeof url === 'string' ? RegExp(url) : url);
        }
    }
    shouldTrackRequest(startContext) {
        return !this.ignoredUrls.some(url => startContext.url.startsWith(url)) && permittedPrefixes.some((prefix) => startContext.url.startsWith(prefix));
    }
    shouldPropagateTraceContext(url) {
        return this.tracePropagationUrls.some(regexp => regexp.test(url));
    }
    getExtraRequestHeaders(span) {
        const extraRequestHeaders = {};
        if (span) {
            const traceId = span.traceId;
            const parentSpanId = span.id;
            const sampled = this.spanFactory.sampler.shouldSample(span.samplingRate);
            extraRequestHeaders.traceparent = buildTraceparentHeader(traceId, parentSpanId, sampled);
        }
        else if (this.spanContextStorage.current) {
            const currentSpanContext = this.spanContextStorage.current;
            const traceId = currentSpanContext.traceId;
            const parentSpanId = currentSpanContext.id;
            const sampled = this.spanFactory.sampler.shouldSample(currentSpanContext.samplingRate);
            extraRequestHeaders.traceparent = buildTraceparentHeader(traceId, parentSpanId, sampled);
        }
        return extraRequestHeaders;
    }
}
function buildTraceparentHeader(traceId, parentSpanId, sampled) {
    return `00-${traceId}-${parentSpanId}-${sampled ? '01' : '00'}`;
}

export { NetworkRequestPlugin };
