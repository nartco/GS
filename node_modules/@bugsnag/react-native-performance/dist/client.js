import { createClient } from '@bugsnag/core-performance';
import createFetchDeliveryFactory from '@bugsnag/delivery-fetch-performance';
import { createXmlHttpRequestTracker } from '@bugsnag/request-tracker-performance';
import { AppState, AppRegistry } from 'react-native';
import { FileSystem } from 'react-native-file-access';
import { AppStartPlugin } from './auto-instrumentation/app-start-plugin.js';
import { NetworkRequestPlugin } from './auto-instrumentation/network-request-plugin.js';
import createClock from './clock.js';
import createSchema from './config.js';
import createIdGenerator from './id-generator.js';
import { NativeBugsnagPerformance } from './native.js';
import persistenceFactory from './persistence/index.js';
import { platformExtensions } from './platform-extensions.js';
import resourceAttributesSourceFactory from './resource-attributes-source.js';
import createRetryQueueFactory from './retry-queue/index.js';
import { createSpanAttributesSource } from './span-attributes-source.js';
import createBrowserBackgroundingListener from './backgrounding-listener.js';

// this is how some internal react native code detects whether the app is running
// in the remote debugger:
// https://github.com/facebook/react-native/blob/e320ab47cf855f2e5de74ea448ec292cf0bbb29a/packages/react-native/Libraries/Utilities/DebugEnvironment.js#L15
// there's no public api for this so we use the same approach
// @ts-expect-error Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.
const isDebuggingRemotely = !global.nativeCallSyncHook && !global.RN$Bridgeless;
const clock = createClock(performance);
const appStartTime = clock.now();
const deliveryFactory = createFetchDeliveryFactory(fetch, clock);
const spanAttributesSource = createSpanAttributesSource();
const deviceInfo = NativeBugsnagPerformance && !isDebuggingRemotely ? NativeBugsnagPerformance.getDeviceInfo() : undefined;
const persistence = persistenceFactory(FileSystem, deviceInfo);
const resourceAttributesSource = resourceAttributesSourceFactory(persistence, deviceInfo);
const backgroundingListener = createBrowserBackgroundingListener(AppState);
// React Native's fetch polyfill uses xhr under the hood, so we only track xhr requests
const xhrRequestTracker = createXmlHttpRequestTracker(XMLHttpRequest, clock);
const idGenerator = createIdGenerator(NativeBugsnagPerformance, isDebuggingRemotely);
const BugsnagPerformance = createClient({
    backgroundingListener,
    clock,
    deliveryFactory,
    idGenerator,
    persistence,
    plugins: (spanFactory, spanContextStorage) => [
        new AppStartPlugin(appStartTime, spanFactory, clock, AppRegistry),
        new NetworkRequestPlugin(spanFactory, spanContextStorage, xhrRequestTracker)
    ],
    resourceAttributesSource,
    schema: createSchema(),
    spanAttributesSource,
    retryQueueFactory: createRetryQueueFactory(FileSystem),
    platformExtensions: (spanFactory, spanContextStorage) => platformExtensions(appStartTime, clock, spanFactory)
});

export { BugsnagPerformance as default };
