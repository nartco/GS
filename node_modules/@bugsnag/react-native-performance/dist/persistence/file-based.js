import { isPersistedProbability } from '@bugsnag/core-performance';
import cuid from '@bugsnag/cuid';
import { Platform } from 'react-native';

const { isCuid } = cuid;
class FileBasedPersistence {
    constructor(file, nativeDeviceIdFile) {
        this.saveQueue = Promise.resolve();
        this.file = file;
        this.nativeDeviceIdFile = nativeDeviceIdFile;
        // https://github.com/bugsnag/bugsnag-cocoa-performance/blob/8d91b55652fededb15ef302daacf993e5917fed4/Sources/BugsnagPerformance/Private/PersistentDeviceID.mm#L181C41-L181C52
        // https://github.com/bugsnag/bugsnag-android-performance/blob/a02d6f2f7417c6d53976ebda9ed8c90b58cb1db1/bugsnag-android-performance/src/main/kotlin/com/bugsnag/android/performance/internal/DeviceIdFilePersistence.kt#L125
        this.nativeDeviceIdJsonKey = Platform.OS === 'ios' ? 'deviceID' : 'id';
    }
    async load(key) {
        // attempt to read the native SDK's device ID file
        // this may not exist as the native SDK isn't necessarily installed or it
        // could have yet to write device ID to disk
        if (key === 'bugsnag-anonymous-id') {
            const nativeDeviceId = await this.readDeviceIdFromNativeSdk();
            if (nativeDeviceId) {
                return nativeDeviceId;
            }
        }
        const existing = await this.readJson();
        switch (key) {
            case 'bugsnag-anonymous-id':
                return isCuid(existing['device-id'])
                    ? existing['device-id']
                    : undefined;
            case 'bugsnag-sampling-probability':
                return isPersistedProbability(existing['sampling-probability'])
                    ? existing['sampling-probability']
                    : undefined;
        }
    }
    async save(key, value) {
        this.saveQueue = this.saveQueue.then(async () => {
            const existing = await this.readJson();
            const dataToBePersisted = {};
            // validate the existing data (if there is any) to try to keep the file as
            // clean as possible
            // this also ensures no extra keys end up in the file
            if (isCuid(existing['device-id'])) {
                dataToBePersisted['device-id'] = existing['device-id'];
            }
            if (isPersistedProbability(existing['sampling-probability'])) {
                dataToBePersisted['sampling-probability'] = existing['sampling-probability'];
            }
            // map the key from core to the key we use in the file
            switch (key) {
                case 'bugsnag-anonymous-id':
                    dataToBePersisted['device-id'] = value;
                    break;
                case 'bugsnag-sampling-probability':
                    dataToBePersisted['sampling-probability'] = value;
                    break;
            }
            try {
                await this.file.write(JSON.stringify(dataToBePersisted));
            }
            catch { }
        });
        await this.saveQueue;
    }
    async readJson() {
        try {
            return JSON.parse(await this.file.read());
        }
        catch (err) {
            return {};
        }
    }
    async readDeviceIdFromNativeSdk() {
        try {
            const contents = await this.nativeDeviceIdFile.read();
            return JSON.parse(contents)[this.nativeDeviceIdJsonKey];
        }
        catch {
        }
    }
}

export { FileBasedPersistence as default };
